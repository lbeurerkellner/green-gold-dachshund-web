import{_ as t,o,c as n,Q as s,k as a,a as e}from"./chunks/framework.c2adf1ba.js";const q=JSON.parse('{"title":"Decorators","description":"","frontmatter":{},"headers":[],"relativePath":"docs/latest/language/decorators.md","filePath":"docs/latest/language/decorators.md"}'),r={name:"docs/latest/language/decorators.md"},l=s(`<h1 id="decorators" tabindex="-1">Decorators <a class="header-anchor" href="#decorators" aria-label="Permalink to &quot;Decorators&quot;">​</a></h1><div class="subtitle">Custom hooks into the query execution process</div><p><em>Variable decorators</em> offer a simple mechanism to execute custom variable value transformations during the decoding process. They enable custom pre-processing, post-processing or streaming of model output.</p><h2 id="post-processing-decorators" tabindex="-1">Post-Processing Decorators <a class="header-anchor" href="#post-processing-decorators" aria-label="Permalink to &quot;Post-Processing Decorators&quot;">​</a></h2><p>The standard use of decorators is to post-process a generated variable value:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">screaming</span>(<span class="hljs-params">value</span>):
    <span class="hljs-string">&quot;&quot;&quot;Decorator to convert a string to uppercase&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> value.upper()

<span class="hljs-string">&quot;Say &#39;this is a test&#39;:<span class="hljs-placeholder">[@screaming TEST]</span>&quot;</span>
</span></code></pre></div>`,6),p=a("div",{class:"language-promptdown vp-adaptive-theme"},[a("button",{title:"Copy Code",class:"copy"}),a("span",{class:"lang"},"promptdown"),a("pre",{"pd-text":`Say 'this is a test': [TEST|THIS IS A TEST]
`,animate:"true",__animate:"true","animate-speed":"50",class:"promptdown promptdown-compiled",style:{opacity:"1"}},[a("p",{"pd-shadow-id":"979",text:"S","pd-insertion-point":"true"},[e("Say 'this is a test': "),a("span",{"pd-shadow-id":"981","pd-instant":"false",text:"",class:"promptdown-var color-pink"},[a("span",{"pd-shadow-id":"982",text:"T",class:"promptdown-var-name"},"TEST"),e("THIS IS A TEST")]),e(`
`)])])],-1),c=s(`<p>The example above shows a simple decorator that converts the generated variable value to uppercase. By default, decorators are applied to the variable value after the variable has finished decoding.</p><p><strong>Value and Prompt Representation</strong> Next to simple use as shown above, the function signature of a decorator can also be extended to obtain more information about the variable context:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">from</span> lmql.runtime.program_state <span class="hljs-keyword">import</span> ProgramState
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Any</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">aslist</span>(<span class="hljs-params">value: <span class="hljs-type">Any</span>, prompt_value: <span class="hljs-built_in">str</span>, context: ProgramState</span>):
    <span class="hljs-string">&quot;&quot;&quot;Decorator to convert a comma-separated string into a List<span class="hljs-placeholder">[<span class="hljs-built_in">str</span>]</span>&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> value.split(<span class="hljs-string">&quot;, &quot;</span>), prompt_value

<span class="hljs-string">&quot;A (comma-separated) list of pancake ingredients: <span class="hljs-placeholder">[@aslist ANSWER]</span>&quot;</span>
</span></code></pre></div>`,3),i=a("div",{class:"language-promptdown vp-adaptive-theme"},[a("button",{title:"Copy Code",class:"copy"}),a("span",{class:"lang"},"promptdown"),a("pre",{"pd-text":`A (comma-separated) list of pancake ingredients: [ANSWER| Flour, Eggs, Milk, Baking Powder, Salt, Butter]
`,animate:"true",__animate:"true","animate-speed":"50",class:"promptdown promptdown-compiled",style:{opacity:"1"}},[a("p",{"pd-shadow-id":"988",text:"A","pd-insertion-point":"true"},[e("A (comma-separated) list of pancake ingredients: "),a("span",{"pd-shadow-id":"990","pd-instant":"false",text:"",class:"promptdown-var color-ochre"},[a("span",{"pd-shadow-id":"991",text:"A",class:"promptdown-var-name"},"ANSWER"),e(" Flour, Eggs, Milk, Baking Powder, Salt, Butter")]),e(`
`)])])],-1),d=s(`<p>Here, the decorator <code>aslist()</code> has three arguments:</p><ul><li><code>value: any</code>: the post-processed value of <code>ANSWER</code> after it has been fully generated</li><li><code>prompt_value: str</code>, the text representation of <code>ANSWER</code> as it was generated by the model</li><li><code>context: ProgramState</code>, the current program state.</li></ul><p>The decorator returns a tuple of <code>(value, prompt_value)</code>, where <code>value</code> is the updated program value for <code>ANSWER</code> and <code>prompt_value</code> is the updated text representation.</p><p>Differentiating between <code>value</code> and <code>prompt_value</code> allows decorators to modify the program value of <code>ANSWER</code> as well as its text representation as used in the prompt. For instance, in the snippet above, the remaining program can operate on <code>ANSWER</code> as the Python <code>List[str]</code> of ingredients, while the model still sees the comma-separated string representation of the list.</p><p>If a decorator does not provide <code>value</code> <em>and</em> <code>prompt_value</code> as a tuple, the prompt value is assumed to be <code>str(value)</code>, i.e. the string representation of the converted value.</p><h2 id="streaming-decorators" tabindex="-1">Streaming Decorators <a class="header-anchor" href="#streaming-decorators" aria-label="Permalink to &quot;Streaming Decorators&quot;">​</a></h2><p>Another form of decorators are <em>streaming decorators</em>. Streaming decorators are applied to the variable value during the decoding process, i.e. the decorator is called for intermediate value of a variable as it is being decoded. This allows for variable-specific streaming of the output:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">from</span> lmql.runtime.program_state <span class="hljs-keyword">import</span> ProgramState

<span class="hljs-meta">@lmql.decorators.streaming</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">stream</span>(<span class="hljs-params">value: <span class="hljs-built_in">str</span>, context: ProgramState</span>):
    <span class="hljs-string">&quot;&quot;&quot;Decorator to stream the variable value&quot;&quot;&quot;</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;VALUE&quot;</span>, [value])

<span class="hljs-string">&quot;Enumerate the alphabet without spaces:<span class="hljs-placeholder">[@stream TEST]</span>&quot;</span>
</span></code></pre></div><p>During execution of this query, <code>stream()</code> is called for each intermediate value of <code>TEST</code>, leading to the output shown above. This allows you to stream output as it is being generated, e.g. to show <a href="./../lib/chat.html">partial responses in a chat application</a> or on the command line.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="hljs"><code><span class="line">VALUE [<span class="hljs-string">&#39;&#39;</span>]
VALUE [<span class="hljs-string">&#39;&#39;</span>]
VALUE [<span class="hljs-string">&#39;\\n&#39;</span>]
VALUE [<span class="hljs-string">&#39;\\n\\n&#39;</span>]
VALUE [<span class="hljs-string">&#39;\\n\\nABC&#39;</span>]
VALUE [<span class="hljs-string">&#39;\\n\\nABCDEF&#39;</span>]
...
</span></code></pre></div><h2 id="pre-processing-decorators" tabindex="-1">Pre-Processing Decorators <a class="header-anchor" href="#pre-processing-decorators" aria-label="Permalink to &quot;Pre-Processing Decorators&quot;">​</a></h2><p>Lastly, a decorator can also hook into query execution right before the generation of a variable begins. For instance, consider the following caching decorator function:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">from</span> lmql.runtime.program_state <span class="hljs-keyword">import</span> ProgramState
<span class="hljs-keyword">from</span> lmql.language.qstrings <span class="hljs-keyword">import</span> TemplateVariable

cached_values = {
    <span class="hljs-string">&quot;ITEM0&quot;</span>: <span class="hljs-string">&quot;A shopping cart&quot;</span>
}

<span class="hljs-meta">@lmql.decorators.pre</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">cache</span>(<span class="hljs-params">variable: TemplateVariable, context: ProgramState</span>):
    <span class="hljs-string">&quot;&quot;&quot;Decorator to cache variable values by name&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> cached_values.get(variable.name, variable)

<span class="hljs-string">&quot;&quot;&quot;A list of things not to forget when going to the supermarket:
-<span class="hljs-placeholder">[@cache ITEM0]</span>
-<span class="hljs-placeholder">[@cache ITEM1]</span>
-<span class="hljs-placeholder">[@cache ITEM0]</span>
&quot;&quot;&quot;</span> <span class="hljs-keyword">where</span> STOPS_BEFORE(ITEM0, <span class="hljs-string">&quot;\\n&quot;</span>) <span class="hljs-keyword">and</span> STOPS_BEFORE(ITEM1, <span class="hljs-string">&quot;\\n&quot;</span>)
</span></code></pre></div><p>Given a pre-determined list of fixed values per variable name like <code>ITEM0</code>, query execution only actually invokes the model for <code>ITEM1</code>. For all occurences of <code>ITEM0</code>, the cached value is used instead.</p><p>For this, a pre-processing decorator either returns the provided <code>variable: TemplateVariable</code> object to indicate that the variable should be generated as usual, or it returns a string value to indicate that the variable should be replaced by a fixed value instead.</p><h2 id="advanced-decorator-behavior" tabindex="-1">Advanced Decorator Behavior <a class="header-anchor" href="#advanced-decorator-behavior" aria-label="Permalink to &quot;Advanced Decorator Behavior&quot;">​</a></h2><h3 id="class-based-decorators" tabindex="-1">Class-Based Decorators <a class="header-anchor" href="#class-based-decorators" aria-label="Permalink to &quot;Class-Based Decorators&quot;">​</a></h3><p>More advanced decorator behavior may require hooking into the query execution process at multiple stages. For this, the <code>lmql.runtime.decorators.LMQLDecorator</code> class can be implemented, an instance of which can then act as a decorator function that is invoked at multiple stages of the query execution process, e.g. you can annotate the variable as <code>&quot;Hello [@DecoratorCls(&lt;args&gt;) WORLD]&quot;</code>.</p><h3 id="multiple-decorators" tabindex="-1">Multiple Decorators <a class="header-anchor" href="#multiple-decorators" aria-label="Permalink to &quot;Multiple Decorators&quot;">​</a></h3><p>Multiple decorators can also be chained on a single variable, e.g.:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;Say &#39;this is a test&#39;:<span class="hljs-placeholder">[@a @b @c TEST]</span>&quot;</span>
</span></code></pre></div><p>During query execution, the pre-stage (if defined), invokes <code>a()</code>, <code>b()</code> and <code>c()</code> in order, passing the result of each decorator to the next one. The post-stage (if defined) then invokes <code>c()</code>, <code>b()</code> and <code>a()</code> in reverse order, passing the result of each decorator to the next one. Streaming-stage decorators do not have a return value, meaning that the order of execution does not have a particular effect.</p><h3 id="decorator-arguments" tabindex="-1">Decorator Arguments <a class="header-anchor" href="#decorator-arguments" aria-label="Permalink to &quot;Decorator Arguments&quot;">​</a></h3><p>Decorators can also be provided with arguments. The implementation of such operators is achieved similarly to the implementation of decorators in standard Python via local variable capture:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prefix</span>(<span class="hljs-params">prefix: <span class="hljs-built_in">str</span></span>):
    <span class="hljs-comment"># actual decorator function</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">value: <span class="hljs-built_in">str</span></span>):
        <span class="hljs-keyword">return</span> prefix + value.strip()
    
    <span class="hljs-keyword">return</span> decorator

<span class="hljs-string">&quot;Say &#39;this is a test&#39;:<span class="hljs-placeholder">[@prefix(<span class="hljs-string">&#39;PREFIX: &#39;</span>) TEST]</span>&quot;</span>

model-output::

Say <span class="hljs-string">&#39;this is a test&#39;</span>: [TEST PREFIX: This <span class="hljs-keyword">is</span> a test]
</span></code></pre></div>`,25),h=[l,p,c,i,d];function u(m,g,v,f,b,_){return o(),n("div",null,h)}const y=t(r,[["render",u]]);export{q as __pageData,y as default};
