import{_ as e,C as t,o as n,c as o,H as l,Q as s}from"./chunks/framework.980cae92.js";const f=JSON.parse('{"title":"Language Reference","description":"","frontmatter":{"sidebar":false,"aside":true,"prev":false,"order":100000,"outline":[2,3,4]},"headers":[],"relativePath":"docs/latest/language/reference.md","filePath":"docs/latest/language/reference.md"}'),r={name:"docs/latest/language/reference.md"},i=s(`<h1 id="language-reference" tabindex="-1">Language Reference <a class="header-anchor" href="#language-reference" aria-label="Permalink to &quot;Language Reference&quot;">​</a></h1><div class="subtitle">LMQL&#39;s core syntax and semantics.</div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>This document is a <strong>work-in-progress effort</strong> to provide a more formal description of LMQL, mainly discussing the syntactic form and corresponding semantics. Please feel free to reach out to the core team if you have any questions or suggestions for improvement.</p></div><h2 id="origins-and-motivation" tabindex="-1">Origins and Motivation <a class="header-anchor" href="#origins-and-motivation" aria-label="Permalink to &quot;Origins and Motivation&quot;">​</a></h2><p>LMQL is a programming language for <em>LLM programming</em>. The primary design objective for LMQL is to provide a simple, yet powerful interface to implement (multi-part) reasoning flows that interact with LLMs in complex and algorithmically controlled ways.</p><p>At the core of LMQL, the following components are of particular importance to achieve this goal:</p><ul><li><p>Robust and type-safe generation via a <strong>constrained decoding engine</strong>.</p></li><li><p>A lightweight <strong>programming model for prompting</strong>, including ways to abstract and modularize query code.</p></li><li><p>A <strong>vendor-agnostic</strong> abstraction over optimized and parallelized <strong>LLM inference</strong>.</p></li></ul><p>The overall goal is to provide a fast and reliable toolchain that facilitates LLM-powered reasoning and applications across domains. This includes already existing use-cases, such as simple chat applications and data parsing, but also extends to more complex applications such as autonomous agents, large-scale data processing, and programmatic reasoning and planning.</p><h2 id="using-lmql" tabindex="-1">Using LMQL <a class="header-anchor" href="#using-lmql" aria-label="Permalink to &quot;Using LMQL&quot;">​</a></h2><p>LMQL&#39;s <a href="#reference-implementation">current reference implementation</a> is written in Python and can be used in a variety of ways:</p><ul><li><p>The <code>lmql playground</code> offers an interactive interface for running, debugging and experimenting with LMQL programs. It is the recommended way to get started with LMQL. An online version of the playground is available at <a href="https://lmql.ai/playground" target="_blank" rel="noreferrer">lmql.ai/playground</a>.</p></li><li><p>LMQL is available as a Python library, with the <code>lmql.query</code> function offering a simple way to use LMQL directly from within Python. For more information, please refer to the <a href="#python-api">Python API</a> section.</p></li><li><p>The <code>lmql run</code> CLI tool can used to run LMQL programs directly from the command line.</p></li></ul><p>For more information and example-based discussion on how to use LMQL, please refer to the <a href="./../">Getting Started</a> guide.</p><h2 id="syntax" tabindex="-1">Syntax <a class="header-anchor" href="#syntax" aria-label="Permalink to &quot;Syntax&quot;">​</a></h2><p>The LMQL language comprises two syntax variants:</p><ul><li><p>The modern, more minimalistic <a href="#modern-syntax">standard syntax</a> that relies on a very small set of language constructs in an otherwise standard Python environment. This syntax is the main focus for the continued development of LMQL.</p></li><li><p>A <em>legacy</em> <a href="#legacy-syntax">standalone syntax</a> that is more static in nature but relevant for standalone LMQL use-cases.</p></li></ul><p>Both syntax variants are compatible and can be used interchangeably.</p><details class="details custom-block"><summary>Grammar Notation</summary><p>We rely on a slightly modified variant of <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form" target="_blank" rel="noreferrer">EBNF</a> to describe the LMQL syntax.</p><p>We denote non-terminals like <code>&lt;SENTENCE&gt;</code> and terminals like <code>&quot;dog&quot;</code>. The <code>[...]?</code> operator denotes an optional element, while the <code>*</code> operator denotes a repetition of zero or more elements. The <code>|</code> operator denotes a choice between two or more elements and non-quoted terminals are regular expressions to match against.</p><p>To avoid notational overhead, we assume that Python fragments like <code>&lt;python.Expr&gt;</code>, refer to standard Python, with the adaptations that arising sub-derivations can also refer back to LMQL expressions (namely <a href="#query-strings">&lt;QUERY_STRING&gt;</a> and <a href="#constraints">&lt;CONSTRAINT_EXPR&gt;</a>), when appropriate.</p><div class="language-grammar vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">grammar</span><pre class="hljs"><code><span class="line">&lt;SENTENCE&gt; <span class="hljs-keyword">:=</span> <span class="hljs-string">&quot;The quick&quot;</span> [<span class="hljs-string">&quot;brown&quot;</span>]<span class="hljs-keyword">?</span> &lt;SUBJECT&gt; &lt;VERB&gt; <span class="hljs-string">&quot;over the lazy dog.&quot;</span>
&lt;SUBJECT&gt; <span class="hljs-keyword">:=</span> <span class="hljs-string">&quot;fox&quot;</span> | <span class="hljs-string">&quot;dog&quot;</span>
&lt;VERB&gt; <span class="hljs-keyword">:=</span> <span class="hljs-string">&quot;jumps&quot;</span> | <span class="hljs-string">&quot;hops&quot;</span> | [.*]{<span class="hljs-number">4</span>}
</span></code></pre></div><p><strong>Examples of valid <code>&lt;SENTENCE&gt;</code> derivations:</strong></p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;The quick fox jumps over the lazy dog.&quot;</span>
<span class="hljs-string">&quot;The quick brown fox jumps over the lazy dog.&quot;</span>
<span class="hljs-string">&quot;The quick dog jumps over the lazy dog.&quot;</span>
<span class="hljs-string">&quot;The quick brown dog hops over the lazy dog.&quot;</span>
<span class="hljs-string">&quot;The quick dog A9_D over the lazy dog.&quot;</span>
</span></code></pre></div></details><h3 id="standard-syntax" tabindex="-1">Standard Syntax <a class="header-anchor" href="#standard-syntax" aria-label="Permalink to &quot;Standard Syntax&quot;">​</a></h3><p>LMQL&#39;s modern syntax can be read as standard Python code, with the addition of one new construct: <a href="#query-strings">query strings</a>. Query strings are just top-level string expressions, that are interpreted as prompts to the underlying LLM. The following grammar describes this syntax in detail.</p><div class="language-grammar vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">grammar</span><pre class="hljs"><code><span class="line">&lt;LMQL_PROGRAM&gt; <span class="hljs-keyword">:=</span> <span class="hljs-comment"># (optional) decoder clause</span>
                  [ <a href="#decoder-clause">&lt;DECODER&gt;</a> [ <span class="hljs-string">&#39;(&#39;</span> <a href="#python-fragments">&lt;python.KeywordArguments&gt;</a> <span class="hljs-string">&#39;)&#39;</span> ]<span class="hljs-keyword">?</span> ]<span class="hljs-keyword">?</span> 
                  <span class="hljs-comment"># program body</span>
                  &lt;STMT&gt;*

&lt;STMT&gt; <span class="hljs-keyword">:=</span> <span class="hljs-comment"># regular python statements</span>
                 <a href="#python-fragments">&lt;python.Stmt&gt;</a> |
                 <span class="hljs-comment"># query strings</span>
                 <a href="#query-strings">&lt;QUERY_STRING&gt;</a> |
                 <span class="hljs-comment"># query strings with inline constraints</span>
                 <a href="#query-strings">&lt;QUERY_STRING&gt;</a> <span class="hljs-string">&#39;where&#39;</span> <a href="#constraints">&lt;CONSTRAINT_EXPR&gt;</a> |
                 <span class="hljs-comment"># query strings with distribution clause</span>
                 <a href="#query-strings">&lt;QUERY_STRING&gt;</a> <span class="hljs-string">&#39;distribution&#39;</span> <a href="#distribution-clauses">&lt;DISTRIBUTION_EXPR&gt;</a>) |

<a href="#query-strings">&lt;QUERY_STRING&gt;</a> <span class="hljs-keyword">:=</span> <a href="#query-strings">&lt;...&gt;</a>

<a href="#constraints">&lt;CONSTRAINT_EXPR&gt;</a> <span class="hljs-keyword">:=</span> <a href="#constraints">&lt;...&gt;</a>

<a href="#distribution-clauses">&lt;DISTRIBUTION_EXPR&gt;</a> <span class="hljs-keyword">:=</span> &lt;VARIABLE&gt; <span class="hljs-string">&#39;in&#39;</span> <a href="#python-fragments">&lt;python.Expr&gt;</a>
</span></code></pre></div><div class="info custom-block"><p class="custom-block-title">Examples of Valid Programs</p><p>Simple program with two <a href="#query-strings">query strings</a></p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;Hello <span class="hljs-placeholder">[WHO]</span>&quot;</span>
<span class="hljs-string">&quot;Goodbye <span class="hljs-placeholder">[WHO]</span>&quot;</span>
</span></code></pre></div><p>Python programs without LMQL constructs are also valid LMQL programs</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="hljs"><code><span class="line">a = <span class="hljs-number">12</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Goodbye, world!&quot;</span>, a)
</span></code></pre></div><p>LMQL programs with control flow</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;Q: What is 2x2? <span class="hljs-placeholder">[ANSWER]</span>&quot;</span>
<span class="hljs-keyword">while</span> ANSWER != <span class="hljs-number">4</span>:
    <span class="hljs-string">&quot;Incorrect, try again: <span class="hljs-placeholder">[ANSWER]</span>&quot;</span>
<span class="hljs-string">&quot;Good job!&quot;</span>
</span></code></pre></div><p>Program with <a href="#query-strings">query strings</a>, <a href="#constraints">constraints</a> and string interpolation</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line">a = <span class="hljs-string">&quot;Alice&quot;</span>
<span class="hljs-string">&quot;Hello <span class="hljs-subst">{a}</span> <span class="hljs-placeholder">[WHO]</span>&quot;</span> <span class="hljs-keyword">where</span> <span class="hljs-built_in">len</span>(TOKENS(WHO)) &lt; <span class="hljs-number">10</span>
<span class="hljs-built_in">print</span>(WHO)
</span></code></pre></div><p>Program with <a href="#query-strings">query strings</a> and <a href="#distribution-clauses">distribution clauses</a></p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;Greet Alice\\n:&quot;</span>
<span class="hljs-string">&quot;Hello <span class="hljs-placeholder">[WHO]</span>&quot;</span> <span class="hljs-keyword">distribution</span> WHO <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>]
</span></code></pre></div></div><h3 id="standalone-syntax" tabindex="-1">Standalone Syntax <a class="header-anchor" href="#standalone-syntax" aria-label="Permalink to &quot;Standalone Syntax&quot;">​</a></h3><p>The standalone query syntax is less flexible than the modern syntax variant and generally considered legacy. It is still supported for standalone use-cases, but users are advised to rely on the modern syntax going forward. Nonetheless, it shares many syntactic constructs with the modern syntax, and is thus described in this document as well.</p><div class="language-grammar vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">grammar</span><pre class="hljs"><code><span class="line">&lt;STANDALONE_QUERY&gt; <span class="hljs-keyword">:=</span> [ <a href="#decoder-clause">&lt;DECODER&gt;</a> [ <span class="hljs-string">&#39;(&#39;</span> <a href="#python-fragments">&lt;python.KeywordArguments&gt;</a> <span class="hljs-string">&#39;)&#39;</span> ]<span class="hljs-keyword">?</span> ]<span class="hljs-keyword">?</span> 
                        &lt;PROMPT&gt;
                     [ <span class="hljs-string">&#39;from&#39;</span> <a href="#model-expressions">&lt;MODEL_EXPR&gt;</a> ]<span class="hljs-keyword">?</span>
                     [ <span class="hljs-string">&#39;where&#39;</span> <a href="#constraints">&lt;CONSTRAINT_EXPR&gt;</a> ]<span class="hljs-keyword">?</span>
                     [ <span class="hljs-string">&#39;distribution&#39;</span> <a href="#distribution-expr">&lt;DISTRIBUTION_EXPR&gt;</a> ]<span class="hljs-keyword">?</span>

<a href="#decoder-clause">&lt;DECODER&gt;</a> <span class="hljs-keyword">:=</span> <span class="hljs-string">&#39;argmax&#39;</span> | <span class="hljs-string">&#39;sample&#39;</span> | <span class="hljs-string">&#39;beam&#39;</span> | <span class="hljs-string">&#39;beam_var&#39;</span> | 
             <span class="hljs-string">&#39;var&#39;</span> | <span class="hljs-string">&#39;best_k&#39;</span> | <a href="#python-fragments">&lt;python.Identifier&gt;</a>

&lt;PROMPT&gt; <span class="hljs-keyword">:=</span> <a href="#query-strings">&lt;QUERY_STRING&gt;</a> | <a href="#python-fragments">&lt;python.Stmt&gt;</a>

<a href="#query-strings">&lt;QUERY_STRING&gt;</a> <span class="hljs-keyword">:=</span> <a href="#query-strings">&lt;...&gt;</a>

<a href="#model-expressions">&lt;MODEL_EXPR&gt;</a> <span class="hljs-keyword">:=</span> <span class="hljs-string">&quot;lmql.model&quot;</span> <span class="hljs-string">&quot;(&quot;</span> <a href="#python-fragments">&lt;python.Arguments&gt;</a> <span class="hljs-string">&quot;)&quot;</span> |
                <a href="#python-fragments">&lt;python.StringLiteral&gt;</a>

<a href="#constraints">&lt;CONSTRAINT_EXPR&gt;</a> <span class="hljs-keyword">:=</span> <a href="#constraints">&lt;...&gt;</a>

<a href="#distribution-clauses">&lt;DISTRIBUTION_EXPR&gt;</a> <span class="hljs-keyword">:=</span> &lt;VARIABLE&gt; <span class="hljs-string">&#39;in&#39;</span> <a href="#python-fragments">&lt;python.Expr&gt;</a>

VARIABLE <span class="hljs-keyword">:=</span> <a href="#python-fragments">&lt;python.Identifier&gt;</a>
</span></code></pre></div><div class="info custom-block"><p class="custom-block-title">Examples</p><p>decoder clause + from</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">argmax</span> <span class="hljs-string">&quot;What is the capital of France? <span class="hljs-placeholder">[ANSWER]</span>&quot;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;gpt2&quot;</span>
</span></code></pre></div><p>decoder clause + where</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">argmax</span> <span class="hljs-string">&quot;What is the capital of France? <span class="hljs-placeholder">[ANSWER]</span>&quot;</span> \\
    <span class="hljs-keyword">where</span> <span class="hljs-built_in">len</span>(TOKENS(ANSWER)) &lt; <span class="hljs-number">10</span>
</span></code></pre></div><p>decoder clause + distribution</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">argmax</span> <span class="hljs-string">&quot;What is the capital of France? <span class="hljs-placeholder">[ANSWER]</span>&quot;</span> \\
    <span class="hljs-keyword">distribution</span> ANSWER <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>]
</span></code></pre></div><p>decoder clause + from + where + distribution</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">argmax</span> 
    <span class="hljs-string">&quot;What is the capital of France? <span class="hljs-placeholder">[ANSWER]</span>&quot;</span> 
<span class="hljs-keyword">from</span>
    <span class="hljs-string">&quot;gpt2&quot;</span>
<span class="hljs-keyword">distribution</span> 
    ANSWER <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>]
</span></code></pre></div></div><h3 id="decoder-clause" tabindex="-1">Decoder Clause <a class="header-anchor" href="#decoder-clause" aria-label="Permalink to &quot;Decoder Clause&quot;">​</a></h3><div class="language-grammar vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">grammar</span><pre class="hljs"><code><span class="line">DECODER_CLAUSE <span class="hljs-keyword">:=</span> <a href="#decoder-clause">&lt;DECODER&gt;</a> [ <span class="hljs-string">&#39;(&#39;</span> <a href="#python-fragments">&lt;python.KeywordArguments&gt;</a> <span class="hljs-string">&#39;)&#39;</span> ]<span class="hljs-keyword">?</span>
</span></code></pre></div><p>The decoder clause defines the decoding algorithm to be used for generation. It is optional and defaults to <code>argmax</code>.</p><p><strong>Algorithms</strong> <code>&lt;DECODER&gt;</code> is one of the runtime-supported decoding algorithms, e.g. <code>argmax</code>, <code>sample</code>, <code>beam</code>, <code>beam_var</code>, <code>var</code>, <code>best_k</code>, or a custom decoder function. For a detailed description please see the <a href="./../language/decoding.html">Decoding</a> documentation chapter.</p><p><strong>Program-Level Decoding</strong> Per query program, only one decoder clause can be specified, i.e. a single decoding algorithm is used to execute all query strings and placeholder variables. This is because decoders act on the program level, and branchingly explore several possible continuations of the program, based on the current program state.</p><h3 id="query-strings" tabindex="-1">Query Strings <a class="header-anchor" href="#query-strings" aria-label="Permalink to &quot;Query Strings&quot;">​</a></h3><p>Query strings represent the core construct for prompt construction and model interaction. They read like top-level string expressions in Python, but are interpreted as prompts to the underlying LLM, including placeholder variables, constraints and string interpolation:</p><div class="language-grammar vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">grammar</span><pre class="hljs"><code><span class="line">QUERY_STRING <span class="hljs-keyword">:=</span> &lt;CONSTRAINED_QSTRING&gt; | &lt;DISTRIBUTION_QSTRING&gt; | &lt;PURE_QSTRING&gt;

<span class="hljs-comment"># qstring with constraints, e.g. &quot;Hello, [NAME]!&quot; where len(TOKENS(NAME)) &lt; 10</span>
&lt;CONSTRAINED_QSTRING&gt; <span class="hljs-keyword">:=</span> &lt;PURE_QSTRING&gt; <span class="hljs-string">&#39;where&#39;</span> <a href="#constraints">&lt;CONSTRAINT_EXPR&gt;</a>

<span class="hljs-comment"># qstring with distribution clause, e.g. &quot;Hello, [NAME]!&quot; distribution NAME in [&quot;Alice&quot;, &quot;Bob&quot;]</span>
&lt;DISTRIBUTION_QSTRING&gt; <span class="hljs-keyword">:=</span> &lt;PURE_QSTRING&gt; <span class="hljs-string">&#39;distribution&#39;</span> &lt;VARIABLE&gt; <span class="hljs-string">&#39;in&#39;</span> <a href="#python-fragments">&lt;python.Expr&gt;</a>

<span class="hljs-comment"># qstring without constraints, e.g. &quot;Hello, [NAME]!&quot;</span>
&lt;PURE_QSTRING&gt; <span class="hljs-keyword">:=</span> &lt;python.StringDelimiter&gt;
                  ( 
                      <span class="hljs-string">&#39;.*&#39;</span> | <span class="hljs-comment"># arbitrary string prompt</span>
                      &lt;PLACEHOLDER_VARIABLE&gt; |
                      &lt;STRING_INTERPOLATION&gt; 
                  )* <span class="hljs-string">&#39;&quot;&#39;</span>
                  &lt;python.StringDelimiter&gt;

<span class="hljs-comment"># placeholder variable, e.g. &quot;[NAME]&quot;</span>
&lt;PLACEHOLDER_VARIABLE&gt; <span class="hljs-keyword">:=</span> <span class="hljs-string">&quot;<span class="hljs-placeholder">[<span class="hljs-string">&quot; <a href="#python-fragments">&lt;python.Identifier&gt;</a> &quot;</span>]</span>&quot;</span> |
                          <span class="hljs-comment"># with type/tactic annotation</span>
                          <span class="hljs-string">&quot;<span class="hljs-placeholder">[<span class="hljs-string">&quot; <a href="#python-fragments">&lt;python.Identifier&gt;</a> &quot;</span>:<span class="hljs-string">&quot; <a href="#python-fragments">&lt;python.Expr&gt;</a> &quot;</span>]</span>&quot;</span> |
                          <span class="hljs-comment"># with decorator</span>
                          <span class="hljs-string">&quot;<span class="hljs-placeholder">[<span class="hljs-string">&quot; &lt;DECORATOR&gt;?  <a href="#python-fragments">&lt;python.Identifier&gt;</a> &quot;</span>]</span>&quot;</span> |
                          <span class="hljs-comment"># with decorator and type/tactic</span>
                          <span class="hljs-string">&quot;<span class="hljs-placeholder">[<span class="hljs-string">&quot; &lt;DECORATOR&gt;?  <a href="#python-fragments">&lt;python.Identifier&gt;</a> &quot;</span>:<span class="hljs-string">&quot; <a href="#python-fragments">&lt;python.Expr&gt;</a> &quot;</span>]</span>&quot;</span>

<span class="hljs-comment"># decorator, e.g. &quot;@fct(a=12)&quot;</span>
&lt;DECORATOR&gt; <span class="hljs-keyword">:=</span> <span class="hljs-string">&quot;@&quot;</span> <a href="#python-fragments">&lt;python.Call&gt;</a> | <span class="hljs-string">&quot;@&quot;</span> [&lt;python.Identifier&gt;]

<span class="hljs-comment"># standard Python f-string interpolation</span>
&lt;STRING_INTERPOLATION&gt; <span class="hljs-keyword">:=</span> <span class="hljs-string">&quot;<span class="hljs-subst">{<span class="hljs-string">&quot; &lt;python.Expr&gt; &quot;</span>}</span>&quot;</span>
</span></code></pre></div><details class="details custom-block"><summary>Examples</summary><p>Without variables:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;Hello, world!&quot;</span> 
</span></code></pre></div><p>With two variable:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;Hello, <span class="hljs-placeholder">[NAME]</span> and <span class="hljs-placeholder">[NAME2]</span>!&quot;</span>
</span></code></pre></div><p>With constraints:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;Hello, <span class="hljs-placeholder">[NAME]</span>!&quot;</span> <span class="hljs-keyword">where</span> <span class="hljs-built_in">len</span>(TOKENS(NAME)) &lt; <span class="hljs-number">10</span>
</span></code></pre></div><p>With decorator:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;Hello, <span class="hljs-placeholder">[@fct(a=<span class="hljs-number">12</span>) NAME]</span>!&quot;</span>
</span></code></pre></div><p>With type annotation:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;Your Age: <span class="hljs-placeholder">[AGE:<span class="hljs-built_in">int</span>]</span>!&quot;</span>
</span></code></pre></div><p>With <a href="./../language/nestedqueries.html">nested call</a> (tactic annotation):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;Q: What is 2x2? A: <span class="hljs-placeholder">[ANSWER: chain_of_thought(shots=<span class="hljs-number">2</span>)]</span>&quot;</span>
</span></code></pre></div><p>With string interpolation:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line">NAME = <span class="hljs-string">&quot;Alice&quot;</span>
<span class="hljs-string">&quot;Hello, <span class="hljs-subst">{NAME}</span>, how old are you: <span class="hljs-placeholder">[AGE:<span class="hljs-built_in">int</span>]</span>?&quot;</span>
</span></code></pre></div></details><div class="warning custom-block"><p class="custom-block-title">Escaping</p><p>To avoid ambiguities, the following characters need to be escaped in query strings:</p><ul><li><code>[</code> and <code>]</code> need to be escaped as <code>[[</code> and <code>]]</code>.</li><li><code>{</code> and <code>}</code> need to be escaped as <code>{ {</code> and <code>}}</code>.</li></ul><p>Python string escaping rules also apply, e.g. string delimiters need to be escaped to disambiguate string boundaries (e.g. <code>&quot;\\&quot;&quot;</code>).</p></div><h4 id="prompt-construction" tabindex="-1">Prompt Construction <a class="header-anchor" href="#prompt-construction" aria-label="Permalink to &quot;Prompt Construction&quot;">​</a></h4><p>The current prompt used for LLM invocations throughout execution, is defined by the concatenation of all query strings executed so far, where placeholder variable are substituted by the respective generated values. Query strings are evaluated along the program&#39;s control flow (e.g. multiple times when called in loops), and left-to-right within a single query string with multiple placeholders. At any point during execution, when an LLM is invoked, the currently active prompt is what is passed to the model.</p><p>For this, newline characters <code>\\n</code> must always be included explicitly, if desired.</p><details class="details custom-block"><summary>Example: Prompt Construction</summary><p>As an example of prompt construction, consider the following program and its corresponding prompt state during execution:</p><div style="display:flex;flex-direction:row;justify-content:space-between;align-items:center;"><div style="width:50%;margin:3pt 20pt 0pt 0pt;"><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;Hello, <span class="hljs-placeholder">[NAME]</span> and <span class="hljs-placeholder">[NAME2]</span>\\n&quot;</span>
        ⬆ <span class="hljs-number">1</span>       ⬆ <span class="hljs-number">2</span>

<span class="hljs-string">&quot;How are you doing?&quot;</span>
⬆ <span class="hljs-number">3</span>

<span class="hljs-string">&quot; <span class="hljs-placeholder">[FEELINGS]</span>&quot;</span>
⬆ <span class="hljs-number">4</span>        ⬆ <span class="hljs-number">5</span>
</span></code></pre></div></div><div><table><thead><tr><th>Point</th><th>Prompt</th><th>Active Variable</th><th>Action</th></tr></thead><tbody><tr><td><code>1</code></td><td><code>&quot;Hello, &quot;</code></td><td><code>NAME</code></td><td>Generate the value of <code>NAME</code></td></tr><tr><td><code>2</code></td><td><code>&quot;Hello, &lt;generated NAME&gt; and &quot;</code></td><td><code>NAME2</code></td><td>Generate the value of <code>NAME2</code></td></tr><tr><td><code>3</code></td><td><code>&quot;Hello, &lt;generated NAME&gt; and &lt;generated NAME2&gt;\\n&quot;</code></td><td>-</td><td>Continue with program execution</td></tr><tr><td><code>4</code></td><td><code>&quot;Hello, &lt;generated NAME&gt; and &lt;generated NAME2&gt;\\nHow are you doing? &quot;</code></td><td><code>FEELINGS</code></td><td>Generate the value of <code>FEELINGS</code></td></tr><tr><td><code>5</code></td><td><code>&quot;Hello, &lt;generated NAME&gt; and &lt;generated NAME2&gt;\\nHow are you doing? &lt;generated FEELINGS&gt;&quot;</code></td><td>-</td><td>End program execution</td></tr></tbody></table></div></div></details><h4 id="placeholder-variables" tabindex="-1">Placeholder Variables <a class="header-anchor" href="#placeholder-variables" aria-label="Permalink to &quot;Placeholder Variables&quot;">​</a></h4><p>Placeholder variables define the templated placeholders an LLM generates text for, and are denoted by <code>[...]</code> square brackets. With respect to the program state, placeholder variables assign the generated values to program variables of the same name.</p><details class="details custom-block"><summary>Example: Variable Assignments</summary><p>With respect to variable assignment, the following code</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line">NAME = <span class="hljs-string">&quot;Alice&quot;</span>
<span class="hljs-string">&quot;Hello <span class="hljs-placeholder">[NAME]</span> and <span class="hljs-placeholder">[NAME2]</span>&quot;</span>
</span></code></pre></div><p>can be understood as the following pseudo-code:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="hljs"><code><span class="line">NAME = <span class="hljs-string">&quot;Alice&quot;</span>
NAME, NAME1 = model.fill_placeholders(<span class="hljs-string">&quot;Hello <span class="hljs-placeholder">[NAME]</span> and <span class="hljs-placeholder">[NAME2]</span>&quot;</span>)
</span></code></pre></div><p>The previous value of <code>NAME</code> is thus overwritten, after executing the query string.</p></details><h4 id="query-string-constraints-and-distributions" tabindex="-1">Query String Constraints and Distributions <a class="header-anchor" href="#query-string-constraints-and-distributions" aria-label="Permalink to &quot;Query String Constraints and Distributions&quot;">​</a></h4><p>Query strings can also be constrained using the <code>&quot;...&quot; where ...</code> syntax. This defines <a href="#constraints">decoding constraints</a>, that only apply locally during generation of the respective query string. For more information, see <a href="#constraints">constraints</a>.</p><p>Similarly, distributions can be constructed using the <code>&quot;...&quot; distribution VAR in [...]</code> syntax. This generates scores for given alternative values for the respective variable, and returns the resulting likelihoods. For more information, see <a href="#distribution-clauses">distribution clauses</a></p><details class="details custom-block"><summary>Example: Constrained Query String</summary><p>A query string with a constraint on the variable <code>NAME</code>:</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;Hello, <span class="hljs-placeholder">[NAME]</span>!&quot;</span> <span class="hljs-keyword">where</span> <span class="hljs-built_in">len</span>(TOKENS(NAME)) &lt; <span class="hljs-number">10</span>
<span class="hljs-string">&quot;Another <span class="hljs-placeholder">[NAME]</span>&quot;</span>
</span></code></pre></div><p>The token length constraint on <code>NAME</code> only applies to generations that are invoked for the first query string, i.e. <code>&quot;Hello, [NAME]!&quot;</code>. The next query string <code>&quot;Another [NAME]&quot;</code> is not affected by the constraint.</p></details><h4 id="types-and-tactics" tabindex="-1">Types and Tactics <a class="header-anchor" href="#types-and-tactics" aria-label="Permalink to &quot;Types and Tactics&quot;">​</a></h4><p>Next to the variable name, a tactic or type can be specified using the <code>&quot;[VAR: &lt;tactic&gt;]&quot;</code> syntax. Syntactically, a tactic expression can be an arbitrary Python expression, however, at runtime, the interpreter expects one of the following:</p><ul><li><p>A type reference like <code>int</code>, supported by the runtime as <a href="#types">LMQL type expression</a></p></li><li><p>A regex expression like <code>r&quot;[a-z]+&quot;</code>, to be enforced as a regex constraint.</p></li><li><p>A reference to another <a href="#query-functions">LMQL query function</a> like <code>chain_of_thought(shots=2)</code>, to be executed as a <a href="./../language/nestedqueries.html">nested query</a>.</p></li></ul><details class="details custom-block"><summary>Example: Tactic Expressions</summary><p>A query string with a integer type annotation on the variable <code>AGE</code>:</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;Your Age: <span class="hljs-placeholder">[AGE:<span class="hljs-built_in">int</span>]</span>!&quot;</span>
</span></code></pre></div><p>A query string with regex tactic on the variable <code>NAME</code>:</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;Hello, <span class="hljs-placeholder">[NAME:r<span class="hljs-string">&quot;[a-z]+&quot;</span>]</span>!&quot;</span>
</span></code></pre></div><p>A query string decoded using a <a href="./../language/nestedqueries.html">nested query</a> on the variable <code>ANSWER</code>:</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;Q: What is 2x2? A: <span class="hljs-placeholder">[ANSWER: chain_of_thought(shots=<span class="hljs-number">2</span>)]</span>&quot;</span>
</span></code></pre></div></details><h4 id="string-interpolation" tabindex="-1">String Interpolation <a class="header-anchor" href="#string-interpolation" aria-label="Permalink to &quot;String Interpolation&quot;">​</a></h4><p>Query strings are compiled to Python <code>f-strings</code> and thus implement regular Python string interpolation semantics using the <code>&quot;Hello {...}&quot;</code> syntax, e.g. <code>&quot;Hello {NAME}&quot;</code> evaluates to <code>&quot;Hello Alice&quot;</code>, given the current program state assigns <code>NAME = &quot;Alice&quot;</code>.</p><h3 id="constraints" tabindex="-1">Constraints <a class="header-anchor" href="#constraints" aria-label="Permalink to &quot;Constraints&quot;">​</a></h3><div class="language-grammar vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">grammar</span><pre class="hljs"><code><span class="line"><a href="#constraints">&lt;CONSTRAINT_EXPR&gt;</a> <span class="hljs-keyword">:=</span> <a href="#constraints">&lt;CONSTRAINT&gt;</a> <span class="hljs-string">&#39;and&#39;</span> CONSTRAINT_EXPR |
                     <a href="#constraints">&lt;CONSTRAINT&gt;</a> <span class="hljs-string">&#39;or&#39;</span> CONSTRAINT_EXPR |
                     <span class="hljs-string">&#39;not&#39;</span> <a href="#constraints">&lt;CONSTRAINT&gt;</a> |
                     <a href="#constraints">&lt;CONSTRAINT&gt;</a>
</span></code></pre></div><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>TODO</p></div><h3 id="model-expressions" tabindex="-1">Model Expressions <a class="header-anchor" href="#model-expressions" aria-label="Permalink to &quot;Model Expressions&quot;">​</a></h3><div class="language-grammar vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">grammar</span><pre class="hljs"><code><span class="line">&lt;MODEL_EXPR&gt; <span class="hljs-keyword">:=</span> <span class="hljs-string">&quot;lmql.model&quot;</span> <span class="hljs-string">&quot;(&quot;</span> &lt;python.Arguments&gt; <span class="hljs-string">&quot;)&quot;</span> |
                &lt;python.StringLiteral&gt;
</span></code></pre></div><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>TODO</p></div><h3 id="distribution-clauses" tabindex="-1">Distribution Clauses <a class="header-anchor" href="#distribution-clauses" aria-label="Permalink to &quot;Distribution Clauses&quot;">​</a></h3><div class="language-grammar vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">grammar</span><pre class="hljs"><code><span class="line">&lt;DISTRIBUTION_EXPR&gt; <span class="hljs-keyword">:=</span> &lt;VARIABLE&gt; <span class="hljs-string">&#39;in&#39;</span> <a href="#python-fragments">&lt;python.Expr&gt;</a>
</span></code></pre></div><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>TODO</p></div><h3 id="python-fragments" tabindex="-1">Python Fragments <a class="header-anchor" href="#python-fragments" aria-label="Permalink to &quot;Python Fragments&quot;">​</a></h3><p>LMQL relies on the following Python grammar fragments, to express parts of the LMQL language.</p><p>For reference, the <a href="https://docs.python.org/3/reference/grammar.html" target="_blank" rel="noreferrer">Python grammar is available here</a>.</p><table><thead><tr><th>Fragment</th><th>Description</th></tr></thead><tbody><tr><td><code>&lt;python.Identifier&gt;</code></td><td>A Python identifier, as defined as <code>NAME</code> in the Python grammar. Examples: <code>a</code>, <code>b</code>, <code>my_var1</code>, <code>MY_VAR2</code></td></tr><tr><td><code>&lt;python.StringLiteral&gt;</code></td><td>A Python string literal, as defined as <code>STRING</code> in the Python grammar. This includes supports for string delimiters, such as single quotes (<code>&#39;</code>), double quotes (<code>&quot;</code>), and triple quotes (<code>&#39;&#39;&#39;</code> or <code>&quot;&quot;&quot;</code>). Examples: <code>&#39;hello&#39;</code>, <code>&quot;world&quot;</code>, <code>&#39;&#39;&#39;hello&#39;&#39;&#39;</code>, <code>&quot;&quot;&quot;world&quot;&quot;&quot;</code></td></tr><tr><td><code>&lt;python.StringDelimiter&gt;</code></td><td>A Python string delimiter, e.g. <code>&#39;</code>, <code>&quot;</code>, <code>&#39;&#39;&#39;</code>, or <code>&quot;&quot;&quot;</code>.</td></tr><tr><td><code>&lt;python.Expr&gt;</code></td><td>A regular Python expression, as defined as <code>expression</code> in the Python grammar. Examples: <code>a</code>, <code>a+b</code>, <code>a(b=12)</code>, <code>a if b else c</code>, <code>a &gt; 2</code>, <code>a == b</code></td></tr><tr><td><code>&lt;python.Stmt&gt;</code></td><td>A regular Python statement, as defined as <code>simple_stmt</code> or <code>compound_stmt</code> in the Python grammar. This includes control flow statements, such as <code>if</code>, <code>for</code>, <code>while</code>, <code>try</code>, <code>with</code>, etc.</td></tr><tr><td><code>&lt;python.Call&gt;</code></td><td>A Python function call, as defined as <code>call</code> in the Python grammar. This includes expressions like <code>a()</code>, <code>a(b=12)</code>, <code>a(b=12, c=13)</code>, <code>a(b=12, c=13, **some_dict)</code>.</td></tr><tr><td><code>&lt;python.KeywordArguments&gt;</code></td><td>Function call keyword arguments, as defined as <code>kwargs</code> in the Python grammar. This includes expressions like <code>()</code>, <code>(a=1, b=2)</code>, <code>(a=1, b=2, **some_dict)</code>.</td></tr><tr><td><code>&lt;python.Arguments&gt;</code></td><td>Function call arguments, as defined as <code>args</code> in the Python grammar. This includes expressions like <code>()</code>, <code>(a, b)</code>, <code>(a, 1, 2, c=2)</code>, <code>(a, b, *some_iterable, **some_dict)</code>.</td></tr></tbody></table><h2 id="types" tabindex="-1">Types <a class="header-anchor" href="#types" aria-label="Permalink to &quot;Types&quot;">​</a></h2>`,66),c=s(`<p>LMQL types can be used to annotate variable during generation, to enforce type constraints on the generated values. The resulting value has two representations:</p><ul><li><p>A <strong>prompt representation</strong>: The value that is used in the prompt, e.g. <code>1234</code> would be represented as the string <code>&quot;1234&quot;</code>.</p></li><li><p>A <strong>program representation</strong>, the value that is returned when the corresponding variable is accessed from the program, e.g. <code>1234</code> would be represented as the Python integer <code>1234</code>.</p></li></ul><p>This distinction helps enable expressive prompting, i.e. represent values in a way that is suitable for the LLM, while also allowing for type-safe and convenient programmatic access to the generated values.</p><table><thead><tr><th>Type</th><th>Description</th><th>Prompt Representation</th><th>Program Representation</th></tr></thead><tbody><tr><td><code>str</code> (default)</td><td>String type, e.g. <code>&quot;hello&quot;</code>, <code>&quot;world&quot;</code>, ...</td><td><code>str_value</code></td><td><a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noreferrer"><code>class str</code></a></td></tr><tr><td><code>int</code></td><td>Integer type, e.g. <code>1</code>, <code>2</code>, <code>3</code>, ...</td><td><code>str(int_value)</code></td><td><a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noreferrer"><code>class int</code></a></td></tr></tbody></table><p>The default type of all placeholder variables is <code>str</code>. To change the type of a variable, the type can be specified as part of the placeholder variable declaration, e.g. <code>[NAME:int]</code> or <code>[NAME:float]</code>, as discussed in the <a href="#types-and-tactics">query strings</a> section.</p><h2 id="query-functions" tabindex="-1">Query Functions <a class="header-anchor" href="#query-functions" aria-label="Permalink to &quot;Query Functions&quot;">​</a></h2><p>Query functions are the functional building blocks for LMQL programs.</p><p>LMQL query functions are defined similar to regular Python function syntax, but using the <code>@lmql.query</code> decorator and by providing the LMQL code as part of the docstring, <em>not</em> the function body.</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-meta">@lmql.query</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">my_query_function</span>(<span class="hljs-params">person</span>):
    <span class="hljs-inline-lmql"><span class="inline-lmql-delim">&#39;&#39;&#39;lmql</span>
    <span class="hljs-string">&quot;Greet <span class="hljs-subst">{person}</span>. Hello <span class="hljs-placeholder">[NAME]</span>!&quot;</span>
    <span class="inline-lmql-delim">&#39;&#39;&#39;</span></span>
</span></code></pre></div><p>From within Python, the same syntax can used to construct Python-callable query functions. Please see to the documentation chapter on <a href="./../lib/python.html">Python Integration</a> for more information.</p><p>LMQL query function can also be declared as <a href="https://docs.python.org/3/library/asyncio-task.html#coroutine" target="_blank" rel="noreferrer"><code>async</code></a> functions, which enables asynchronous execution.</p><h3 id="function-calling-and-arguments" tabindex="-1">Function Calling and Arguments <a class="header-anchor" href="#function-calling-and-arguments" aria-label="Permalink to &quot;Function Calling and Arguments&quot;">​</a></h3><p>A query function can be called as a standard function from within LMQL or Python code. It can also be called as a <a href="./../language/nestedqueries.html">nested query</a> from within a query string. <code>async</code> query functions require the <code>await</code> keyword to be used.</p><p><strong>Arguments</strong> In addition to the function arguments specified in the function signature, query functions also provide the following additional arguments, that can be used to control the generation process:</p><ul><li><code>model</code>: The <a href="./../lib/generations.html#lmql-llm-objects"><code>lmql.LLM</code></a> model reference (or string identifier) to be used for generation.</li><li><code>decoder</code>: The decoding algorithm to be used for generation. See also the <a href="#decoder-clause">decoder clause</a> section.</li><li><code>output_writer</code>: The output writer callback to be used during generation. See also documentation chapter on <a href="./../lib/output.html">output streaming</a> section.</li><li><code>**kwargs</code>: Additional keyword arguments, passed to decoder and interpreter, such as <code>temperature</code>, <code>chunksize</code>, etc.</li></ul><h2 id="reference-implementation" tabindex="-1">Reference Implementation <a class="header-anchor" href="#reference-implementation" aria-label="Permalink to &quot;Reference Implementation&quot;">​</a></h2><p>LMQL&#39;s current reference implementation is written in Python and also available as a Python library. The reference implementation of the syntax and semantics described in this document is available via Git at <a href="https://github.com/eth-sri/lmql" target="_blank" rel="noreferrer">github.com/eth-sri/lmql</a>.</p><h3 id="compiler-and-runtime" tabindex="-1">Compiler and Runtime <a class="header-anchor" href="#compiler-and-runtime" aria-label="Permalink to &quot;Compiler and Runtime&quot;">​</a></h3><p>The LMQL Python compiler translates LMQL programs into asynchroneous, brancheable Python code according to the semantics described in this document. The resulting program is then executed using the LMQL runtime, which implements (constrained) decoding algorithms, optimizations and model support via several backends.</p><h3 id="hybrid-parser" tabindex="-1">Hybrid Parser <a class="header-anchor" href="#hybrid-parser" aria-label="Permalink to &quot;Hybrid Parser&quot;">​</a></h3><p>For parsing, the implementation leverages a hybrid approach, largely relying on the existing Python parser (<code>ast.parse</code>) and grammar, adding additional parsing logic only for LMQL-specific constructs. This approach allows us to be compliant with the Python grammar, while also allowing us to extend the language with additional constructs, that are not part of the original Python grammar. To parse the standalone syntax, we segment the input on a token level and then call the parser several times to obtain the final AST for e.g. the prompt clause, the where clause or the distribution clause.</p>`,21);function p(d,h,u,g,m,y){const a=t("Badge");return n(),o("div",null,[i,l(a,{text:"Work in Progress"}),c])}const b=e(r,[["render",p]]);export{f as __pageData,b as default};
