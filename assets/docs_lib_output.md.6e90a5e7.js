import{_ as e,o as t,c as a,Q as s}from"./chunks/framework.980cae92.js";const v=JSON.parse('{"title":"Output Streaming","description":"","frontmatter":{},"headers":[],"relativePath":"docs/lib/output.md","filePath":"docs/lib/output.md"}'),n={name:"docs/lib/output.md"},o=s(`<h1 id="output-streaming" tabindex="-1">Output Streaming <a class="header-anchor" href="#output-streaming" aria-label="Permalink to &quot;Output Streaming&quot;">​</a></h1><div class="subtitle">Stream Query Progress In Real Time</div><p>LMQL supports many forms of communicating query progress and results to the surrounding context, including the ability to stream intermediate values to the caller or a client connected via HTTP.</p><p>This chapter first discusses the standard output writers, supported out of the box, and then discusses how to create you custom output writers, to implement more advanced streaming scenarios.</p><h2 id="standard-output-writers" tabindex="-1">Standard Output Writers <a class="header-anchor" href="#standard-output-writers" aria-label="Permalink to &quot;Standard Output Writers&quot;">​</a></h2><p>To simply print the current query output to the standard output, you can use the <code>lmql.printing</code> output writer. This will show query progress during execution, as well as intermediate validation results.</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">await</span> lmql.run(<span class="hljs-string">&quot;&#39;Q: Hello\\\\n A:<span class="hljs-placeholder">[WHAT]</span>&#39;&quot;</span>, 
               output_writer=lmql.printing)
</span></code></pre></div><div class="language-output vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">output</span><pre class="hljs"><code><span class="line">Q: Hello
A: Hi there! How can I assist you<span class="hljs-keyword">?</span>

 valid=<span class="hljs-literal">True</span>, final=fin
</span></code></pre></div><p>Alternatively, if you want to only stream the result for a specific variable, you can use the <code>lmql.stream(&quot;VAR&quot;)</code> output writer. This will only print the result for the variable <code>VAR</code>, as it is generated by the query.</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">await</span> lmql.run(<span class="hljs-string">&quot;&#39;<span class="hljs-subst">{:user}</span> Hello\\\\n <span class="hljs-subst">{:assistant}</span><span class="hljs-placeholder">[RESPONSE]</span>&#39;&quot;</span>, 
               model=<span class="hljs-string">&quot;chatgpt&quot;</span>,
               output_writer=lmql.stream(<span class="hljs-string">&quot;RESPONSE&quot;</span>))
</span></code></pre></div><div class="language-output vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">output</span><pre class="hljs"><code><span class="line">Hello! How can I assist you today<span class="hljs-keyword">?</span>
</span></code></pre></div><p>Lastly, there are also the options <code>lmql.headless</code> and <code>lmql.silent</code> to disable all input and output, and to disable all output, respectively. The difference between the two is that <code>headless</code> will raise an exception if the query asks for user input (via <code>input()</code>), while <code>silent</code> will ask for user input, but not print anything to the standard output.</p><h2 id="custom-output-writer" tabindex="-1">Custom Output Writer <a class="header-anchor" href="#custom-output-writer" aria-label="Permalink to &quot;Custom Output Writer&quot;">​</a></h2><p>Next to the standard output writers, you can also provide your own implementation and pass it via <code>output_writer=</code> when running a query.</p><p>The basic interface for an output writer is as follows:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseOutputWriter</span>:
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">input</span>(<span class="hljs-params">self, *args</span>):
        <span class="hljs-string">&quot;&quot;&quot;
        Handle user input with an input prompt of *args. This is invoked when a query asks for user input via \`await input()\`.

        Returns:
            str: The user input.
        &quot;&quot;&quot;</span>

    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_interpreter_head_state</span>(<span class="hljs-params">self, variable, head, prompt, <span class="hljs-keyword">where</span>, trace, is_valid, is_final, mask, num_tokens, program_variables</span>): 
        <span class="hljs-string">&quot;&quot;&quot;
        Called whenever the query interpreter progresses in a meaningful way (e.g. new token added, new variable added, variable updated, etc.).

        Parameters:
            variable (str): 
                The name of the currently active variable.
            head (int): 
                The index of the current interpretation head (deprecated, will always be 0).
            prompt (str): 
                The full interaction trace/prompt of the query.
            where (object): 
                The AST representation of the queries validation condition.
            trace (object): 
                The evaluation trace of evaluating &#39;where&#39; on the current program variables during generation.
            is_valid (bool): 
                Whether the current program variables satisfy the validation condition.
            is_final (bool): 
                Whether the value of &#39;valid&#39; can be considered final (i.e. decoding more tokens will not change the value of &#39;valid&#39;).
            mask (np.ndarray): 
                Currently active token mask.
            num_tokens (int): 
                Number of tokens in the current &#39;prompt&#39;.
            program_variables (ProgramState): 
                The current program state (lmql.runtime.program_state). E.g. program_variables.variable_values is a mapping of variable names to their current values.
        &quot;&quot;&quot;</span>
</span></code></pre></div><p>Based on this interface, you can implement your own output writer to implement custom streaming. For examples of how this interface can be used, see the implementation of the standard output writers in <code>lmql.runtime.output_writer</code>.</p>`,17),r=[o];function l(i,p,u,c,d,h){return t(),a("div",null,r)}const g=e(n,[["render",l]]);export{v as __pageData,g as default};
