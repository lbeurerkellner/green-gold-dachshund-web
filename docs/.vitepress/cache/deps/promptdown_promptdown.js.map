{
  "version": 3,
  "sources": ["../../../node_modules/promptdown/promptdown.js"],
  "sourcesContent": ["/** standard color palette. */\nconst COLORS = [\"blue\", \"purple\", \"pink\", \"magenta\", \"red\", \"orange\", \"lightorange\", \"yellow\", \"ochre\"];\n\n/** Simple str-to-hashcode function. */\nfunction strHashCode(str) {\n    let hash = 0;\n    if (str.length == 0) {\n        return hash;\n    }\n    for (let i = 0; i < str.length; i++) {\n        let char = str.charCodeAt(i);\n        hash = ((hash << 5) - hash) + char;\n        hash = hash & hash;\n    }\n    return Math.abs(hash);\n}\n\n/**\n * DFS traversal of the DOM, returning the first element with the `pd-insertion-point` attribute.\n */\nfunction getInsertionPointDFS(el) {\n    if (el.nodeType != Node.ELEMENT_NODE) {\n        return null;\n    }\n    if (el.hasAttribute(\"pd-insertion-point\")) {\n        return el;\n    } else {\n        for (let i = 0; i < el.childNodes.length; i++) {\n            let ip = getInsertionPointDFS(el.childNodes[i]);\n            if (ip) {\n                return ip;\n            }\n        }\n    } \n    return null;\n}\n\n/**\n * Returns the root element of the current PromptDown shadow DOM.\n */\nfunction getPdRoot(el) {\n    return el.pdRoot || el;\n}\n\n/**\n * Finds the current insertion point in the provided root element.\n * \n * The insertion point is the element where the next character will be appended to.\n * It is marked by the `pd-insertion-point` attribute.\n */\nfunction getInsertionPoint(el) {\n    let ip = getInsertionPointDFS(el);\n    if (ip) ip.pdRoot = el;\n    return ip;\n}\n\n/**\n * Unmarks `el` as the current insertion point.\n */\nfunction clearIp(el) {\n    el.removeAttribute(\"pd-insertion-point\");\n    el.querySelectorAll(\".promptdown-cursor\").forEach(c => c.remove());\n}\n\n/**\n * Marks `el` as the current insertion point.\n */\nfunction setIp(el) {\n    el.setAttribute(\"pd-insertion-point\", \"true\");\n}\n\n/**\n * Appends text to the current insertion point.\n * \n * This means either appending the text to the current text node or creating a new text node\n * if the current insertion point is not a text node.\n */\nfunction appendText(el, text) {\n    if (!text) return;\n\n    if (text == \"↩\") {\n        let span = new ShadowElement(\"span\")\n        span.setAttribute(\"style\", \"opacity: 0.2; font-family: monospace;\");\n        span.classList.add(\"promptdown-control-character\");\n        let textChild = new ShadowTextNode(\"↩\");\n        span.appendChild(textChild);\n        el.appendChild(span);\n        return;\n    }\n\n    if (el.childNodes.length == 0) {\n        el.setAttribute(\"text\", el.getAttribute(\"text\") + text);\n        el.appendChild(new ShadowTextNode(text));\n    } else {\n        let lastChild = el.childNodes[el.childNodes.length - 1];\n        \n        if (lastChild && lastChild.nodeType == Node.TEXT_NODE) {\n            lastChild.textContent += text;\n        } else {\n            let textNode = new ShadowTextNode(text);\n            el.appendChild(textNode);\n        }\n    }\n}\n\n/**\n * Returns the type of the current insertion point.\n * \n * Possible types are:\n * - h1: The insertion point is inside an h1 element.\n * - p: The insertion point is inside a p element.\n * - var-name: The insertion point is inside a variable name span.\n * - var-value: The insertion point is inside a variable value span.\n */\nfunction getElementType(el) {\n    let tagName = el.tagName.toLowerCase();\n    if (tagName == \"span\") {\n        if (el.classList.has(\"promptdown-var-name\")) {\n            return \"var-name\";\n        } else if (el.classList.has(\"promptdown-var\")) {\n            return \"var-value\";\n        } else {\n            return tagName;\n        }\n    } else {\n        return tagName;\n    }\n}\n\n/**\n * Inserts a new prompt variable at the current `ip` insertion point.\n * \n * @param {ShadowElement} ip The insertion point.\n * @param {boolean} instant Whether the variable content should be rendered instantly or typed in.\n */\nfunction newVar(ip, instant=false) {\n    let span = new ShadowElement(\"span\");\n    span.classList.add(\"promptdown-var\");\n    span.setAttribute(\"pd-instant\", instant);\n    \n    let span_name = new ShadowElement(\"span\");\n    span_name.setAttribute(\"class\", \"promptdown-var-name\");\n    setIp(span_name);\n    span.appendChild(span_name);\n    ip.appendChild(span);\n    clearIp(ip);\n    \n    return {\n        instant: true\n    }\n}\n\n/**\n * Removes any color- class from a provided element.\n */\nfunction removeColorClass(el) {\n    Array.from(el.classList).filter(c => c.startsWith(\"color-\")).forEach(c => {\n        el.classList.remove(c);\n    });\n}\n\n/**\n * Executes the command at the current `ip` insertion point.\n * \n * Executes the command either by mutating the DOM or by returning a command\n * to the wrapping digestion loop (e.g. slowDigest) in the case of a `wait` command.\n */\nfunction runCmd(ip) {\n    // get first span as cmd name and remaining #text as parameters\n    let cmd = ip.childNodes[0].innerText;\n    let params = Array.from(ip.childNodes).slice(1).map(c => c.textContent).join(\"\");\n\n    if (cmd == \"wait\") {\n        return {\n            instant: true,\n            cmd: \"wait\",\n            time: parseFloat(params)\n        }\n    } else if (cmd == \"begin\") {\n        let div = new ShadowElement(\"p\");\n        div.classList.add(\"promptdown-container\");\n        div.style.display = \"inline\"\n        setIp(div);\n        div.setAttribute(\"id\", params);\n        clearIp(ip.parentNode);\n        ip.parentNode.appendChild(div);\n\n        return {\n            instant: true\n        }\n    } else if (cmd == \"end\") {\n        // traverse up until we find a container\n        if (ip.parentNode.getAttribute(\"id\") == params) {\n            clearIp(ip.parentNode);\n            setIp(ip.parentNode.parentNode);\n            return {\n                instant: true\n            }\n        }\n    } else if (cmd == \"fade\") {\n        let root = getPdRoot(ip);\n        let el = root.querySelector(\"#\" + params);\n        if (el) {\n            el.classList.add(\"faded\");\n        }\n    } else if (cmd == \"hide\")  {\n        let root = getPdRoot(ip);\n        let el = root.querySelector(\"#\" + params);\n        if (el) {\n            el.style.display = \"none\";\n        }\n    }\n\n    return {\n        instant: true,\n        cmd: ip\n    }\n}\n\n/**\n * Extracts key-value arguments from a variable name expression, e.g. [var(param1=1,param2=2)| ...].\n */\nfunction getArgs(name) {\n    let argument_values = {}\n\n    if (name.includes(\"(\")) {\n        // regex match for name and arguments\n        let match = name.match(/([^(]+)\\(([^)]*)\\)/);\n        if (match) {\n            name = match[1];\n            let args = match[2].split(\",\");\n            args.forEach(arg => {\n                let argMatch = arg.match(/([^=]+)=([^=]+)/);\n                if (argMatch) {\n                    let argName = argMatch[1];\n                    let argValue = argMatch[2];\n                    argument_values[argName] = argValue;\n                }\n            });\n        }\n    }\n\n    \n    // also return name without arguments\n    argument_values.name = name;\n\n    return argument_values;\n}\n\nfunction latex(pd_text) {\n    // replace [VAR|content] with \\strprm{content}\n    // replace \\n with \\\\ in latex\n\n    // \\strprm{Instruction} \\strdet{Trigger}\\\\\n    // Intermediate State\\\\\n    // \\strprm{Instruction} \\strdet{Trigger} \\strmod{[Intermediate State]} \\strprm{Instruction} \\strdet{Trigger} \\strmod{[ANSWER]} \n    // % \\hfill\\textcolor{my-full-green}{\\Huge\\cmark}\n\n    pd_text = pd_text.replace(\"[:copy]\", \"\");\n    \n    return `\\\\begin{tcolorbox}[boxrule=0pt, colback=black!5,frame empty]\n        ${pd_text.replace(/\\[([^\\]]+)\\|([^\\]]+)\\]/g, \"\\\\strprm{\\\\textbf{ $1} $2 }\").replace(/\\n/g, \"\\\\\\\\\")}\n\\\\end{tcolorbox}`\n}\n\nfunction copyToClipboard(root, button, as_latex=false) {\n    let pdText = root.getAttribute(\"pd-text\");\n    if (as_latex) pdText = latex(pdText);\n    // remove [:copy]\n    pdText = pdText.replace(/\\[:copy\\]$/, \"\");\n    // remove explicit line breaks\n    pdText = pdText.replace(/↩/g, \"\");\n    navigator.clipboard.writeText(pdText);\n    button.innerText = \"Copied!\";\n    window.setTimeout(() => {\n        button.innerText = \"Copy\";\n    }, 1000);\n}\n\nfunction getButton(ip) {\n    let name = ip.innerText;\n\n    if (name == \"copy\") {\n        return {\n            label: \"Copy\",\n            callback: function(event) {\n                let preElement = getPdRoot(ip).el;\n                // check for alt key\n                let as_latex = event.altKey;\n                copyToClipboard(preElement, this, as_latex);\n            }\n        };\n    }\n}\n\n/**\n * `digest` transition function, updating a given Shadow DOM character by character,\n * incrementally rendering the provided PromptDown text.\n * \n * All state is stored in the provided ShadowElement, which is mutated by this function. \n * This allows us to stream output into the DOM without having to re-render the entire\n * DOM on every change and without maintaining a separate state.\n * \n * @param {ShadowElement} el The ShadowElement to render the text to.\n * @param {string} c The next character to digest.\n */\nfunction digest(el, c) {\n    let ip = getInsertionPoint(el);\n    let elementType = getElementType(ip);\n    \n    if (!ip.getAttribute(\"text\")) {\n        ip.setAttribute(\"text\", \"\");\n    }\n    \n    let instant = ip.getAttribute(\"pd-instant\") == \"true\";\n    let nextIsInstant = ip.getAttribute(\"pd-next-is-instant\") == \"true\";\n\n    if (ip.getAttribute(\"pd-next-is-instant\")) {\n        ip.removeAttribute(\"pd-next-is-instant\");\n    }\n\n    if (c == \"!\") {\n        ip.setAttribute(\"pd-next-is-instant\", \"true\");\n        return {\n            instant: true\n        }\n    }\n\n    // handle backslash escaping\n    if (c == \"\\\\\") {\n        ip.setAttribute(\"pd-next-is-escaped\", \"true\");\n        return {\n            instant: true\n        }\n    }\n    if (ip.getAttribute(\"pd-next-is-escaped\")) {\n        ip.removeAttribute(\"pd-next-is-escaped\");\n        appendText(ip, c);\n        return {\n            instant: true\n        }\n    }\n\n    if (elementType == \"h1\") {\n        if (c == \"\\n\") {\n            let p = new ShadowElement(\"p\");\n            setIp(p);\n            ip.parentNode.insertBefore(p, ip.nextSibling);\n            clearIp(ip);\n            return {\n                instant: true\n            }\n        } else {\n            appendText(ip, c);\n            return {\n                instant: true\n            }\n        }\n    } else if (elementType == \"p\") {\n        if (c == \"[\") {\n            return newVar(ip, nextIsInstant || instant);\n        }\n    } else if (elementType == \"var-name\") {\n        if (c == \"_\" && ip.innerText == \"\") {\n            ip.style.display = \"none\";\n            return {\n                instant: true\n            }\n        } else if (c == \"@\" && ip.innerText == \"\") {\n            ip.style.display = \"none\";\n            ip.parentNode.setAttribute(\"pd-cmd\", \"true\");\n            ip.parentNode.classList.add(\"cmd\");\n            \n            return {\n                instant: true\n            }\n        } else if (c == \":\" && ip.innerText == \"\") {\n            if (getPdRoot(ip).getAttribute(\"animate\") == \"true\") {\n                let button = new ShadowButton(\"↺ Replay\");\n                button.classList.add(\"promptdown-button-replay\");\n                button.addEventListener(\"click\", () => {\n                    let root = getPdRoot(ip).el;\n                    pd(root);\n                    return {\n                        instant: true,\n                        cmd: \"stop\"\n                    }\n                })\n                ip.parentNode.appendChild(button);\n            }\n            ip.style.display = \"none\";\n            ip.setAttribute(\"pd-component\", \"true\");\n            ip.parentNode.classList.add(\"color-none\")\n            \n            return {\n                instant: true\n            }\n        } else if (c == \":\") {\n            if (ip.innerText == \"bubble\") {\n                // insert div container in-between ip.parentNode and ip.parentNode.parentNode\n                let div = new ShadowElement(\"div\");\n                div.classList.add(\"promptdown-bubble-container\");\n                ip.parentNode.parentNode.insertBefore(div, ip.parentNode);\n                div.appendChild(ip.parentNode);\n\n                ip.parentNode.classList.add(\"promptdown-bubble\");\n                if (getPdRoot(ip).getAttribute(\"animate\") == \"true\") {\n                    ip.parentNode.classList.add(\"animate\");\n                    div.classList.add(\"animate\");\n                }\n                ip.parentNode.classList.delete(\"promptdown-var-name\");\n                // remove color- class\n                removeColorClass(ip.parentNode);\n            }\n        } else if (c == \"|\") {\n            // leave current span and go to parent span with insertion point\n            let parent = ip.parentNode;\n            let name = ip.innerText;\n            \n            if (name.startsWith(\"_\")) {\n                name = name.slice(1);\n            }\n\n            // check for variable arguments , e.g. var(param1=1,param2=2)\n            let args = getArgs(name);\n\n            if (args.code) {\n                ip.parentNode.classList.add(\"code_in_prompt\");\n                ip.parentNode.classList.add(\"color-none\");\n            }\n\n            // update name\n            ip.innerText = args.name;\n\n            if (parent.classList.has(\"promptdown-bubble\")) {\n                let role = ip.innerText.split(\":\")[1];\n                parent.classList.add(role);\n                parent.parentNode.classList.add(role);\n            } else {\n                if (name == \"\") {\n                    ip.parentNode.classList.add(\"color-none\");\n                } else {\n                    // choose a color\n                    let color = COLORS[strHashCode(name) % COLORS.length];\n                    ip.parentNode.classList.add(\"color-\" + color);\n                }\n            }\n\n            clearIp(ip);\n            setIp(parent);\n            \n            return {\n                instant: true\n            }\n        } else {\n            if (c == \"]\" && ip.getAttribute(\"pd-component\") == \"true\") {\n                let button = getButton(ip);\n                if (button) {\n                    ip.tagName = \"button\";\n                    ip.style.display = \"inline-block\";\n                    ip.classList.add(ip.innerText);\n                    ip.innerText = button.label;\n                    ip.addEventListener(\"click\", button.callback);\n                    \n                    return {\n                        instant: true\n                    }\n                }\n            }\n\n            appendText(ip, c);\n            return {\n                instant: true\n            }\n        }\n    } else if (elementType == \"var-value\") {\n        if (c == \"]\") {\n            // leave current span and go to parent span with insertion point\n            let parent = ip.parentNode;\n            // skip bubble container\n            if (parent.classList.has(\"promptdown-bubble-container\")) {\n                parent = parent.parentNode;\n            }\n            parent.setAttribute(\"pd-ignore-whitespace\", \"true\");\n            setIp(parent);\n            clearIp(ip);\n            \n            if (ip.classList.has(\"cmd\")) {\n                return runCmd(ip);\n            }\n            return {\n                instant: instant\n            }\n        } else if (c == \"[\") {\n            return newVar(ip, instant || nextIsInstant);\n        } else {\n            appendText(ip, c);\n            return {\n                instant: instant\n            }\n        }\n    }\n\n    if (c == \"#\") {\n        // remove potentially empty p element\n        if (ip.innerText == \"\") {\n            ip.remove();\n        }\n\n        // append new H1 element\n        let h1 = new ShadowElement(\"h1\");\n        setIp(h1);\n        el.appendChild(h1);\n        clearIp(ip);\n        return {\n            instant: true\n        }\n    }\n\n    // plain white-space is always instant\n    if (c == \" \" || c == \"\\n\") {\n        if (ip.getAttribute(\"pd-ignore-whitespace\") == \"true\") {\n            ip.removeAttribute(\"pd-ignore-whitespace\");\n            appendText(ip, c);\n            return {\n                instant: true\n            }\n        }\n\n        appendText(ip, c);\n        return {\n            instant: true\n        }\n    }\n\n    appendText(ip, c);\n\n    return {\n        instant: instant\n    }\n}\n\nlet SHADOW_ELEMENT_ID = 0;\n\n/**\n * Shadow DOM representation of an HTML element/node.\n * \n * This class is used to represent the DOM structure of the PromptDown output.\n * \n * Use the `sync` method to sync the shadow DOM with the actual DOM, as anchored by the root\n * element's `el` property.\n */\nclass ShadowElement {\n    constructor(el_or_tagname) {\n        if (typeof el_or_tagname == \"string\") {\n            this.el = document.createElement(el_or_tagname);\n        } else {\n            this.el = el_or_tagname;\n        }\n        \n        this.tagName = this.el.tagName;\n        this.attributes = {};\n        this._style = {}\n        this.classList = new Set();\n        \n        this.children = [];\n        this.nodeType = Node.ELEMENT_NODE\n        this.parentNode = null;\n\n        this.syncedElementId = null;\n        \n        this.id = SHADOW_ELEMENT_ID++;\n        this.eventListeners = {};\n    }\n\n    addEventListener(event, callback) {\n        this.eventListeners[event] = callback;\n    }\n\n    sync(el=null) {\n        el = el || this.el;\n        if (!el) {\n            throw \"No element to sync with\";\n        }\n        \n        el.removeAttribute(\"pd-insertion-point\");\n        Object.keys(this.attributes).forEach(name => {\n            el.setAttribute(name, this.attributes[name]);\n        })\n\n        Object.keys(this._style).forEach(name => {\n            el.style[name] = this._style[name];\n        })\n        el.class = \"\";\n        this.classList.forEach(c => {\n            el.classList.add(c);\n        })\n\n        // extract existing children and their shadows\n        let existing_children = Array.from(el.childNodes);\n        let mapping = {};\n        let not_synced = new Set();\n        existing_children.forEach(child => {\n            if (child.getAttribute && child.getAttribute(\"pd-shadow-id\")) {\n                mapping[child.getAttribute(\"pd-shadow-id\")] = child;\n                not_synced.add(child);\n            } else if (child.pd_shadow_id) {\n                mapping[child.pd_shadow_id] = child;\n                not_synced.add(child);\n            }\n        });\n        \n        this.children.forEach(child => {\n            let shadow = mapping[child.id];\n            not_synced.delete(shadow);\n            \n            if (shadow) {\n                child.sync(shadow);\n            } else {\n                let element = null;\n                if (child.tagName == \"TEXT\") {\n                    element = document.createTextNode(\"\");\n                    element.pd_shadow_id = child.id;\n                } else if (child.tagName == \"BUTTON\") {\n                    element = document.createElement(\"button\");\n                    element.pd_shadow_id = child.id;\n                } else {\n                    element = document.createElement(child.tagName);\n                    element.setAttribute(\"pd-shadow-id\", \"\" + child.id);\n                }\n                el.appendChild(element);\n                child.sync(element);\n                element.shadowElement = child;\n            }\n        });\n\n        // update event listeners\n        Object.keys(this.eventListeners).forEach(event => {\n            el.removeEventListener(event, this.eventListeners[event]);\n            el.addEventListener(event, this.eventListeners[event]);\n        })\n\n        // remove remaining children\n        not_synced.forEach(child => {\n            el.removeChild(child);\n        });\n    }\n\n    setAttribute(name, value) {\n        this.attributes[name] = \"\" + value;\n        if (name == \"class\") {\n            this.classList = new Set(value.split(\" \"));\n        }\n    }\n\n    getAttribute(name) {\n        return this.attributes[name];\n    }\n\n    hasAttribute(name) {\n        return this.attributes[name] != undefined;\n    }\n\n    removeAttribute(name) {\n        delete this.attributes[name];\n    }\n\n    get childNodes() {\n        return this.children;\n    }\n\n    get innerText() {\n        return this.children.map(c => c.innerText).join(\"\");\n    }\n\n    set innerText(value) {\n        this.children = [new ShadowTextNode(value)];\n    }\n\n    get style() {\n        return this._style;\n    }\n\n    set style(value) {\n        this._style = value;\n    }\n\n    appendChild(child) {\n        this.children.push(child);\n        if (child.parentNode) {\n            child.parentNode.removeChild(child);\n        }\n        child.parentNode = this;\n    }\n\n    insertBefore(child, ref) {\n        if (!ref) {\n            this.appendChild(child);\n            return;\n        }\n\n        let index = this.children.indexOf(ref);\n        if (index == -1) {\n            throw \"Reference node not found\";\n        }\n        this.children.splice(index, 0, child);\n\n        if (child.parentNode) {\n            child.parentNode.removeChild(child);\n        }\n        child.parentNode = this;\n    }\n\n    querySelectorAll(selector) {\n        if (!selector.startsWith(\".\")) {\n            throw \"Only class selectors are supported\";\n        }\n        let className = selector.slice(1);\n        let matches = [];\n        this.children.forEach(child => {\n            if (child.classList.has(className)) {\n                matches.push(child);\n            }\n            child.querySelectorAll(selector).forEach(c => {\n                matches.push(c);\n            })\n        });\n        if (this.classList.has(className)) {\n            matches.push(this);\n        }\n        \n        return matches;\n    }\n\n    querySelector(selector) {\n        if (!selector.startsWith(\"#\")) {\n            throw \"Only id selectors are supported\";\n        }\n        let id = selector.slice(1);\n        if (this.attributes.id == id) {\n            return this;\n        }\n        let matches = [];\n        this.children.forEach(child => {\n            let match = child.querySelector(selector);\n            if (match) {\n                matches.push(match);\n            }\n        });\n        if (matches.length == 0) {\n            return null;\n        }\n        return matches[0];\n    }\n\n    remove() {\n        if (this.parentNode) {\n            this.parentNode.children = this.parentNode.children.filter(c => c != this);\n        }\n    }\n\n    removeChild(child) {\n        this.children = this.children.filter(c => c != child);\n    }\n}\n\n/**\n * Shadow DOM representation of a button.\n */\nclass ShadowButton extends ShadowElement {\n    constructor(label) {\n        super(\"button\");\n\n        this.label = label;\n        this.eventListeners = {};\n    }\n\n    addEventListener(event, callback) {\n        this.eventListeners[event] = callback;\n    }\n\n    sync(el=null) {\n        super.sync(el);\n\n        el.innerText = this.label;\n        Object.keys(this.eventListeners).forEach(event => {\n            el.addEventListener(event, this.eventListeners[event]);\n        })\n    }\n}\n\n/**\n * Shadow DOM representation of a text node.\n */\nclass ShadowTextNode extends ShadowElement {\n    constructor(content) {\n        super(\"text\");\n        this.nodeType = Node.TEXT_NODE;\n        this.textContent = content;\n    }\n\n    sync(el=null) {\n        if (!el) {\n            throw \"No element to sync with\";\n        }\n        el.textContent = this.textContent\n    }\n\n    get innerText() {\n        return this.textContent;\n    }\n}\n\n/**\n * Converts the provided element into a PromptDown canvas, rendering the provided\n * PromptDown text into it.\n * \n * The element can configure the following attributes:\n * - animate=\"true|false\": Whether to animate the rendering of the text.\n * - animate-speed=\"number\": The number of characters to reveal per second.\n * - animate-step-size=\"number\": The number of characters to reveal per step.\n * \n * @param {HTMLElement} el The element to render the PromptDown output into.\n */\nexport function pd(el, text=null, ssr=false) {\n    // obtain PromptDown text\n    let pd_text = el.getAttribute(\"pd-text\") || el.innerText;\n    if (text != null) {\n        pd_text = text;\n    }\n    // reset element\n    el.innerText = \"\";\n    el.setAttribute(\"pd-text\", pd_text);\n    \n    \n    // parse configuration parameters\n    let animate = el.getAttribute(\"animate\") == \"true\";\n    let speed = animate ? 1000.0 / parseFloat(el.getAttribute(\"animate-speed\")) : 0;\n    if (isNaN(speed)) {\n        speed = 6.66;\n    }\n    let step_size = parseInt(el.getAttribute(\"animate-step-size\"));\n    if (isNaN(step_size)) {\n        step_size = 4;\n    }\n\n    // create shadow element\n    el = new ShadowElement(el);\n    el.setAttribute(\"animate\", animate);\n\n    // create default root element\n    el.appendChild(new ShadowElement(\"p\"));\n    el.childNodes[0].setAttribute(\"pd-insertion-point\", \"true\");\n    \n    // animates in element\n    el.style.opacity = 1;\n\n    // digest pd_text character by character\n    if (animate && !ssr) {\n        // timed animation\n        slowDigest(el, pd_text, speed, 0, step_size);\n    } else {\n        // instant rendering\n        pd_text.split(\"\").forEach(c => digest(el, c));\n        el.sync();\n    }\n}\n/** \n * Plays a timed animation streaming in the provided text character by character,\n * into the view defined by the provided ShadowElement.\n * \n * @param {ShadowElement} el The ShadowElement to render the text to.\n * @param {string} text The full text to digest character by character.\n * @param {number} timeout The timeout in-between non-instant characters.\n * @param {number} step The current step in the animation.\n * @param {number} step_size The number of characters to digest in one chunk without waiting in-between.\n */\nfunction slowDigest(el, text, timeout, step=0, step_size=1) {\n    if (!text) {\n        el.sync();\n        let ip = getInsertionPoint(el);\n        clearIp(ip);\n        return;\n    }\n    \n    let change = digest(el, text[0]);\n    if (change.cmd == \"wait\") {\n        el.sync()\n        window.setTimeout(() => {\n            slowDigest(el, text.slice(1), timeout, 0, step_size);\n        }, change.time);\n        return;\n    } else if (change.cmd == \"stop\") {\n        return;\n    }\n\n    if (change.instant) {\n        slowDigest(el, text.slice(1), timeout, step + 1, step_size);\n    } else {\n        if (step % step_size == 0) {\n            el.sync()\n            window.setTimeout(() => {\n                slowDigest(el, text.slice(1), timeout, step + 1, step_size);\n            }, timeout);\n        } else {\n        slowDigest(el, text.slice(1), timeout, step + 1, step_size);\n        }\n    }\n}\n\n// browser polyfill\n\nif (!Node) {\n    var Node = {\n        ELEMENT_NODE: 1,\n        TEXT_NODE: 3\n    }\n}\n\nif (!document) {\n    var document = {\n        createElement: function(tagName) {\n            return new StringDOMElement(tagName);\n        },\n        createTextNode: function(text) {\n            return new StringDOMElement(\"text\");\n        }\n    }\n}\n\n\nexport class StringDOMElement {\n    constructor(tagName) {\n        this.tagName = tagName;\n        this.attributes = {};\n        this.childNodes = [];\n        this.classList = new Set();\n        this.style = {};\n    }\n\n    set innerText(value) {\n        this.childNodes = [new StringDOMElement(\"text\")];\n        this.childNodes[0].textContent = value;\n    }\n\n    get innerText() {\n        return this.childNodes.map(c => c.innerText).join(\"\");\n    }\n\n    getElementType() {\n        return this.tagName == \"text\" ? Node.TEXT_NODE : Node.ELEMENT_NODE;\n    }\n\n    setAttribute(name, value) {\n        if (name == \"class\") {\n            this.classList = new Set(value.split(\" \"));\n            return;\n        }\n\n        this.attributes[name] = value;\n    }\n\n    getAttribute(name) {\n        if (name == \"class\") {\n            return Array.from(this.classList).join(\" \");\n        }\n\n        return this.attributes[name];\n    }\n\n    removeAttribute(name) {\n        delete this.attributes[name];\n    }\n\n    appendChild(child) {\n        this.childNodes.push(child);\n    }\n\n    toHTML(top=true) {\n        if (this.tagName == \"text\") {\n            return this.textContent;\n        }\n\n        if (top) {\n            this.attributes[\"animate\"] = \"true\";\n            this.attributes[\"__animate\"] = \"true\";\n            this.attributes[\"animate-speed\"] = \"50\";\n        }\n\n        let html = `<${this.tagName}`;\n        Object.keys(this.attributes).filter(name => name != \"class\").forEach(name => {\n            html += ` ${name}=\"${this.attributes[name]}\"`;\n        })\n        if (this.classList.size > 0) {\n            html += ` class=\"${Array.from(this.classList).join(\" \")}\"`;\n        }\n        if (Object.keys(this.style).length > 0) {\n            html += ` style=\"`;\n            Object.keys(this.style).forEach(name => {\n                html += `${name}: ${this.style[name]};`;\n            })\n            html += `\"`;\n        }\n        html += \">\";\n        this.childNodes.forEach(child => {\n            html += child.toHTML(false);\n        })\n        html += `</${this.tagName}>`;\n        return html;\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
